const PROMISE_STATUS_PENDING="pending",PROMISE_STATUS_FULFILLED="fulfilled",PROMISE_STATUS_REJECTED="rejected";function executorFnWithCatchError(executorFn,value,resolve,reject){try{const res=executorFn(value);res&&resolve(res)}catch(error){reject(error)}}class Promise{constructor(executor){this.status="pending",this.value=void 0,this.onResolveFns=[],this.onRejectFns=[];const resolve=value=>{"pending"===this.status&&(this.value=value,queueMicrotask(()=>{this.status="fulfilled",console.log("resolve",value,this===p),this.onResolveFns.forEach(onResolve=>{onResolve&&onResolve(value)})}))},reject=reason=>{"pending"===this.status&&(this.value=reason,queueMicrotask(()=>{this.status="rejected",this.onRejectFns.forEach(onReject=>{onReject&&onReject(reason)})}))};executor(resolve,reject)}then(onResolve,onReject){return new Promise((resolve,reject)=>{"fulfilled"===this.status&&executorFnWithCatchError(onResolve,this.value,resolve,reject),"rejected"===this.status&&executorFnWithCatchError(onReject,this.value,resolve,reject),"pending"===this.status&&(onResolve&&this.onResolveFns.push(()=>{executorFnWithCatchError(onResolve,this.value,resolve,reject)}),onResolve&&this.onRejectFns.push(()=>{executorFnWithCatchError(onReject,this.value,resolve,reject)}))})}catch(onReject){this.then(void 0,onReject)}finally(){}static resolve(){}static reject(){}static all(){}static allSettled(){}static race(){}static any(){}}const p=new Promise((resolve,reject)=>{resolve(111),reject(222)});p.then(res=>{throw console.log("res3",res),222}).then(void 0,err=>{console.log("err3",err)});